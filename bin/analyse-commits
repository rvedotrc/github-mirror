#!/usr/bin/env ruby

# This just analyses *all* the interesting commits found to date
# - there is no incremental behaviour yet.

require 'json'
require 'set'

def extract_secrets(text)
  text = text.join ""

  # Public keys: 20 chars, A-Z0-9, starting with "AKIA"
  # Secret keys: 40 chars, A-Za-z0-9+/, but allow for \ or \\ before the
  # non-alphanumeric chars

  public_access_keys = text.scan /\bAKIA[A-Z0-9]{16}\b/
  secret_access_keys = text.scan /(?:[A-Za-z0-9]|\\*[\/+]){40,}/
  secret_access_keys = secret_access_keys.map {|t| t.gsub /\\/, ""}
  secret_access_keys = secret_access_keys.select {|t| t.length == 40}

  public_access_keys.sort!
  secret_access_keys.sort!
  {
    public_access_keys: public_access_keys,
    secret_access_keys: secret_access_keys,
  }
end

def permute_key_pairs(secrets)
  secrets[:public_access_keys].map do |p|
    secrets[:secret_access_keys].map do |s|
      [ p, s ]
    end
  end.flatten(1)
end

Dir.glob("var/*/*/interesting.json").each do |interesting_file|
  data = JSON.parse(IO.read interesting_file)

  data.each do |c|
    commit, file, hunk = c["commit"], c["file"], c["hunk"]

    old_text = hunk.select {|l| l.match /^[ -]/}.map {|l| l[1..-1]}
    new_text = hunk.select {|l| l.match /^[ +]/}.map {|l| l[1..-1]}

    old_secrets = extract_secrets old_text
    new_secrets = extract_secrets new_text

    next if old_secrets == new_secrets

    old_permutations = permute_key_pairs(old_secrets)
    new_permutations = permute_key_pairs(new_secrets)

    puts JSON.pretty_generate({
      "local_dir" => File.dirname(interesting_file),
      "commit" => commit,
      "file" => file,
      # "hunk" => hunk,
      "old_secrets" => old_secrets,
      "new_secrets" => new_secrets,
      "old_permutations" => old_permutations,
      "new_permutations" => new_permutations,
    })
  end

end

