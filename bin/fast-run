#!/usr/bin/env ruby

$: << "lib"
require 'rosarium'
require 'github_mirror'
require 'json'

@config = JSON.parse(IO.read "etc/github-mirror.json")

def do_page(page)
  # puts "page=#{page.inspect[0..100]}"
  Rosarium::Promise.all(page.map {|repo| do_repo repo})
end

def repo_allowed?(repo, org)
  @config["github"]["allow_orgs"].nil? or @config["github"]["allow_orgs"].include? org
end

def do_repo(repo)
  # puts "repo=#{repo.inspect}"
  url = repo["git_url"]
  pushed_at = repo["pushed_at"]
  org = url.split('/')[3]

  unless repo_allowed?(repo, org)
    return Rosarium::Promise.resolve(
      repo.merge(allowed: false)
    )
  end

  local_dir = url.gsub("git://github.com/", "var/github/").gsub(/\.git$/, "")

  cloner = Rosarium::Promise.execute do
    GithubMirror::RepositoryCloner.new(local_dir, false).run(url, pushed_at)
  end

  aws = cloner.then do
    GithubMirror::AwsCredentialsCommitScanner.new(local_dir).run
  end.then do |state|
    { log: state["log"] }
  end.catch do |e|
    puts "FAILED to update #{local_dir} for AwsCredentialsCommitScanner: #{e}"
    { error: e }
  end

  sweary = cloner.then do
    GithubMirror::SwearyCommitScanner.new(local_dir).run
  end.then do |state|
    { log: state["log"] }
  end.catch do |e|
    puts "FAILED to update #{local_dir} for SwearyCommitScanner: #{e}"
    { error: e }
  end

  Rosarium::Promise.all([aws, sweary]).then do |r_aws, r_sweary|
    repo.merge(
      aws_credentials_commits: r_aws,
      sweary_commits: r_sweary,
    )
  end
end

def do_all_repositories
  github_client = GithubMirror::GithubClient.get("etc/github-mirror.json")
  json_cache = GithubMirror::JSONCache.new("var/list-repos.json", 3600*10)
  lister = GithubMirror::RepositoryLister.new(github_client, json_cache)
  # The iterator pattern doesn't play at all well with promises ("FiberError:
  # fiber called across threads" - i.e. the iterators are mutable), so use the
  # block pattern instead.
  Rosarium::Promise.all(
    lister.each_page.map {|page| do_page page}
  ).then do |pages|
    pages.flatten
  end
end

def make_sweary_commit_log(v)
  c = []

  v.each do |r|
    r[:sweary_commits] or next
    log = r[:sweary_commits][:log]
    if log and !log.empty?
      log = log.map {|l| {git_url: r["git_url"]}.merge log_entry: l}
      c.concat log
    end
  end

  c.uniq! {|l| l[:log_entry].first}

  c.sort_by! do |l|
    l[:log_entry].find {|t| t.start_with? "Date:"}
  end

  c
end

all_repositories = do_all_repositories

save_fast_run = all_repositories.then do |v|
  GithubMirror::JsonCache.new("var/fast-run.json", nil).write(v)
end

save_sweary_commits = all_repositories.then do |v|
  l = make_sweary_commit_log v
  GithubMirror::JsonCache.new("var/sweary-commits.json", nil).write(l)
end

try_keys = all_repositories.then do |v|
  collection = GithubMirror::AwsKeyPairCollection.new("var/aws-key-pairs.json")
  GithubMirror::AwsKeyChecker.new.run(collection, v, {})
end

Rosarium::Promise.all([ save_fast_run, save_sweary_commits, try_keys ]).value!

# eof fast-run
