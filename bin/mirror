#!/usr/bin/env ruby
# vi: set ts=2 sw=2 :

$: << "lib"

require 'github_api'
require 'github_mirror/cacheing_thing'
require 'github_mirror/github_paginating_enumerator'
require 'github_mirror/repository_processor'
require 'json'
require 'rosarium'
require 'rosarium/promise_concurrency_limiter'

begin
  stdout_mutex = Mutex.new

  define_method(:puts) do |*args|
    stdout_mutex.synchronize do
      super *args
    end
  end
end

config = JSON.parse(IO.read 'etc/github-mirror.json')
user = config['github']['user']
pass = config['github']['pass']

github_client = Github.new(
  basic_auth: user+':'+pass,
  auto_pagination: false,
)

promises = []
limiter = Rosarium::PromiseConcurrencyLimiter.new(3)
FileUtils.rm_f 'var/stop'

ttl = config['repositories_list_ttl'].to_i
GithubMirror::CacheingThing.new('var/repositories.json', Time.now - ttl) do
  github_client.repos.list.lazy_each
end.each do |repo|
  next unless config['github']['allow_orgs'].include? repo['owner']['login']

  promise = limiter.promise do
    Rosarium::Promise.execute do
      next :cancelled if File.exists? 'var/stop'
      GithubMirror::RepositoryProcessor.new('var/github', repo).process
    end
  end

  promise.define_singleton_method(:repo) { repo }

  promises << promise
end

begin
  Rosarium::Promise.all_settled(promises).then do
    puts ""
    promises.select(&:rejected?).each do |promise|
      puts "FAILED for #{promise.repo['full_name']} : #{promise.reason}"
    end
    puts ""
    fulfilled_count = promises.count &:fulfilled?
    rejected_count = promises.count &:rejected?
    puts "All done - #{fulfilled_count} completed and #{rejected_count} crashed"
  end.value!
ensure
  Rosarium::EXECUTOR.wait_until_idle
end

# eof
