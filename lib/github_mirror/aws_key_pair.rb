require 'time'

module GithubMirror

  # This class models the testing of AWS access / secret keys to see if they
  # are valid. We do not cover temporary keys, i.e. those with a session
  # token.

  # In AWS, each IAM user key pair consists of an access key, and a secret key.
  # Both the access key and secret key are generated by AWS; the user has no
  # control over the key contents.  Both keys are short strings.  Each key
  # pair's lifecycle is that it is created (at the user's request), then
  # perhaps eventually deleted.

  # Keys are created as "active".  Only "active" keys may be used to
  # successfully authenticate.  Active keys can be changed to inactive.
  # Inactive keys can be changed to active.  Both active and inactive keys can
  # be deleted.

  # In terms of testing the keys: STS "GetCallerIdentity" allows the caller to
  # retrieve their identity (and this call is special in that *all*
  # authenticated users are allowed to make this call; IAM policies do not
  # apply).  Therefore GetCallerIdentity (with an access key and secret key)
  # can yield one of three results:

  # - the user's ARN (which tells us that the key pair is valid, and active)
  # - InvalidClientTokenId (which tells us that the access key is either not
  # valid, or inactive)
  # - SignatureDoesNotMatch (which tells us that the access key is valid and
  # active, but that the secret access key is wrong)

  # There is *no way to distinguish deleted from inactive*, but the two are
  # different, in that a deleted key can never come back, but an inactive key
  # could do so. If we *could* distinguish the two, we could periodically
  # check inactive keys to see when they become either active, or deleted; and
  # once they become deleted, we can stop checking. But since we *can't*
  # distinguish them, we have to treat InvalidClientTokenId as "deleted" â€“
  # otherwise we'd never know when to stop checking each invalid key.

  class AwsKeyPair

    # The access key
    attr_reader :access_key_id

    # The state of this key:
    # - :secret_not_found (we know the access key is valid and active, but we
    # haven't found the right secret key yet)
    # - :secret_found (key is valid and active, and we have the secret)
    # - :bad_access_key (key is deleted / inactive)
    attr_reader :state

    # If state == :secret_not_found, this tracks which secrets we've tried
    # (and were wrong), so we can avoid re-testing them.
    attr_reader :wrong_secret_access_keys

    # If state == :secret_found, this contains the secret that worked.  It's
    # also retained if the state later changes to :bad_access_key.
    attr_reader :right_secret_access_key

    # The time at which we first found the correct secret
    attr_reader :date_secret_found_first
    # The time at which we last verified that the correct secret was still working
    attr_reader :date_secret_found_last
    # The time at which we first knew the key to be inactive / deleted
    attr_reader :date_bad

    # If state is (or ever was) :secret_found, this is the ARN of the user the
    # key was for.
    attr_reader :user_arn

    def self.init_secret_not_found(access_key_id, secret_access_key)
      allocate.instance_eval do
        @access_key_id = access_key_id
        @wrong_secret_access_keys = [ secret_access_key ]
        @state = :secret_not_found
        self
      end
    end

    def self.init_secret_found(access_key_id, secret_access_key, user_arn, time)
      allocate.instance_eval do
        @access_key_id = access_key_id
        @right_secret_access_key = secret_access_key
        @user_arn = user_arn
        @date_secret_found_first = @date_secret_found_last = copy_time time
        @state = :secret_found
        self
      end
    end

    def self.init_bad_access_key(access_key_id, time)
      allocate.instance_eval do
        @access_key_id = access_key_id
        @date_bad = copy_time time
        @state = :bad_access_key
        self
      end
    end

    def add_secret_not_found(secret_access_key)
      if state == :secret_not_found
        @wrong_secret_access_keys = (@wrong_secret_access_keys + [secret_access_key]).sort.uniq
      end
    end

    def add_secret_found(secret_access_key, user_arn, time)
      case state
      when :secret_not_found
        @wrong_secret_access_keys = nil
        @right_secret_access_key = secret_access_key
        @user_arn = user_arn
        @date_secret_found_first = @date_secret_found_last = copy_time time
        @state = :secret_found
      when :secret_found
        # We assume time always goes forwards
        @date_secret_found_last = copy_time time
      end
    end

    def add_bad_access_key(time)
      case state
      when :secret_not_found, :secret_found
        @wrong_secret_access_keys = nil
        @date_bad = copy_time time
        @state = :bad_access_key
      end
    end

    def to_h
      instance_variables.map do |sym|
        v = instance_variable_get sym
        unless v.nil?
          if v.kind_of? Time
            v = serialise_time v
          elsif v.kind_of? Symbol
            v = v.to_s
          end
          [ sym.to_s[1..-1], v ]
        end
      end.reject(&:nil?).to_h
    end

    def self.from_h(h)
      allocate.instance_eval do
        h.entries.each do |k, v|
          if k.start_with? "date_"
            v = deserialise_time v
          elsif k == "state"
            v = v.to_sym
          end
          instance_variable_set "@#{k}".to_sym, v
        end
        self
      end
    end

    private

    def copy_time(t)
      if t
        Time.at(t.to_i)
      end
    end

    def serialise_time(t)
      if t
        t.utc.strftime '%Y-%m-%dT%H:%M:%S+0000'
      end
    end

    def deserialise_time(t)
      if t
        Time.parse t
      end
    end

  end

end
